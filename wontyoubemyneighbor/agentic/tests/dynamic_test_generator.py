"""
Dynamic Test Generator - Self-Testing Network Agents

Enables network agents to autonomously generate and execute pyATS AEtest
scripts based on their current state, configuration, and detected conditions.

This is the core of the "self-testing network" concept where agents:
1. Analyze their state and configuration
2. Generate appropriate test scripts dynamically
3. Execute tests via pyATS MCP
4. Interpret results and take corrective action

The agent becomes both the test writer AND the test executor.
"""

import asyncio
import logging
import json
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Callable
from enum import Enum
from datetime import datetime
import textwrap

logger = logging.getLogger("DYNAMIC_TEST_GENERATOR")


class TestCategory(Enum):
    """Categories of dynamic tests agents can generate"""
    CONNECTIVITY = "connectivity"      # Ping, reachability
    PROTOCOL_STATE = "protocol_state"  # OSPF neighbors, BGP peers
    INTERFACE = "interface"            # Link state, errors, MTU
    ROUTING = "routing"                # Route presence, path validation
    PERFORMANCE = "performance"        # Latency, throughput
    SECURITY = "security"              # ACL validation, authentication
    CONVERGENCE = "convergence"        # Recovery time, failover
    COMPLIANCE = "compliance"          # Config standards, best practices


class TestTrigger(Enum):
    """What triggers dynamic test generation"""
    SCHEDULED = "scheduled"            # Regular interval
    STATE_CHANGE = "state_change"      # Neighbor up/down, route change
    ANOMALY = "anomaly"                # Detected issue
    HUMAN_REQUEST = "human_request"    # Operator asked
    PEER_REQUEST = "peer_request"      # Another agent asked
    SELF_ASSESSMENT = "self_assessment"  # Agent decided to test itself


@dataclass
class GeneratedTest:
    """A dynamically generated test"""
    test_id: str
    test_name: str
    category: TestCategory
    trigger: TestTrigger
    description: str
    script: str  # The actual pyATS AEtest script
    test_data: Dict[str, Any]  # TEST_DATA embedded in script
    expected_outcomes: List[str]
    generated_at: str = field(default_factory=lambda: datetime.now().isoformat())
    agent_id: Optional[str] = None
    context: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "test_id": self.test_id,
            "test_name": self.test_name,
            "category": self.category.value,
            "trigger": self.trigger.value,
            "description": self.description,
            "script": self.script,
            "test_data": self.test_data,
            "expected_outcomes": self.expected_outcomes,
            "generated_at": self.generated_at,
            "agent_id": self.agent_id,
            "context": self.context,
        }


@dataclass
class TestExecutionResult:
    """Result from executing a dynamic test"""
    test_id: str
    success: bool
    passed: int
    failed: int
    errored: int
    sections: List[Dict[str, Any]]
    raw_output: Optional[str] = None
    recommendations: List[str] = field(default_factory=list)
    executed_at: str = field(default_factory=lambda: datetime.now().isoformat())
    duration_ms: int = 0

    def to_dict(self) -> Dict[str, Any]:
        return {
            "test_id": self.test_id,
            "success": self.success,
            "passed": self.passed,
            "failed": self.failed,
            "errored": self.errored,
            "sections": self.sections,
            "raw_output": self.raw_output,
            "recommendations": self.recommendations,
            "executed_at": self.executed_at,
            "duration_ms": self.duration_ms,
        }


class DynamicTestGenerator:
    """
    Generates pyATS AEtest scripts dynamically based on agent state.

    The agent analyzes its configuration and current state to determine
    what tests are appropriate, then generates executable test scripts.

    Example flow:
        1. Agent detects OSPF neighbor went down
        2. Generator creates connectivity test to that neighbor
        3. Test executes via pyATS MCP
        4. Results inform agent's next action (alert, reroute, etc.)
    """

    # AEtest script template - the agent fills in TEST_DATA and test logic
    AETEST_TEMPLATE = textwrap.dedent('''
        """
        {description}

        Dynamically generated by: {agent_id}
        Generated at: {generated_at}
        Trigger: {trigger}
        Category: {category}
        """

        from pyats import aetest
        from pyats.topology import loader
        import logging

        logger = logging.getLogger(__name__)

        # Test data embedded by the agent
        TEST_DATA = {test_data}


        class CommonSetup(aetest.CommonSetup):
            """Common setup for dynamic test"""

            @aetest.subsection
            def connect_to_devices(self, testbed):
                """Connect to devices under test"""
                for device_name in TEST_DATA.get("devices", []):
                    device = testbed.devices.get(device_name)
                    if device:
                        try:
                            device.connect(log_stdout=False)
                            self.parent.parameters[device_name] = device
                            logger.info(f"Connected to {{device_name}}")
                        except Exception as e:
                            self.failed(f"Failed to connect to {{device_name}}: {{e}}")
                    else:
                        self.failed(f"Device {{device_name}} not found in testbed")


        {test_classes}


        class CommonCleanup(aetest.CommonCleanup):
            """Common cleanup for dynamic test"""

            @aetest.subsection
            def disconnect_devices(self):
                """Disconnect from all devices"""
                for device_name in TEST_DATA.get("devices", []):
                    device = self.parent.parameters.get(device_name)
                    if device and device.connected:
                        device.disconnect()
                        logger.info(f"Disconnected from {{device_name}}")


        if __name__ == "__main__":
            import argparse
            from pyats.topology import loader

            parser = argparse.ArgumentParser()
            parser.add_argument("--testbed", required=True)
            args = parser.parse_args()

            testbed = loader.load(args.testbed)
            aetest.main(testbed=testbed)
    ''').strip()

    def __init__(self, agent_config: Dict[str, Any]):
        """
        Initialize the dynamic test generator

        Args:
            agent_config: Agent's TOON configuration
        """
        self.agent_config = agent_config
        self.agent_id = agent_config.get("id", "unknown")
        self.router_id = agent_config.get("r", "0.0.0.0")
        self.interfaces = agent_config.get("ifs", [])
        self.protocols = agent_config.get("protos", [])
        self._test_counter = 0

    def _next_test_id(self) -> str:
        """Generate unique test ID"""
        self._test_counter += 1
        timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
        return f"{self.agent_id}_dynamic_{timestamp}_{self._test_counter}"

    # =========================================================================
    # Connectivity Tests
    # =========================================================================

    def generate_ping_test(
        self,
        targets: List[str],
        source_device: str,
        trigger: TestTrigger = TestTrigger.SELF_ASSESSMENT,
        count: int = 5,
        timeout: int = 2,
    ) -> GeneratedTest:
        """
        Generate a ping connectivity test

        Args:
            targets: List of IP addresses to ping
            source_device: Device to ping from
            trigger: What triggered this test
            count: Number of pings per target
            timeout: Ping timeout in seconds
        """
        test_id = self._next_test_id()

        test_data = {
            "devices": [source_device],
            "targets": targets,
            "ping_count": count,
            "ping_timeout": timeout,
            "success_threshold": 80,  # 80% success required
        }

        test_class = textwrap.dedent('''
            class PingConnectivityTest(aetest.Testcase):
                """Verify connectivity to target hosts"""

                @aetest.test
                def ping_targets(self):
                    """Ping all configured targets"""
                    device = self.parent.parameters.get(TEST_DATA["devices"][0])
                    results = {}

                    for target in TEST_DATA["targets"]:
                        try:
                            # Execute ping command
                            output = device.execute(
                                f"ping {target} count {TEST_DATA['ping_count']} timeout {TEST_DATA['ping_timeout']}"
                            )

                            # Parse success rate (simplified)
                            if "100 percent" in output.lower() or "0% packet loss" in output.lower():
                                results[target] = {"success": True, "loss": 0}
                            elif "0 percent" in output.lower() or "100% packet loss" in output.lower():
                                results[target] = {"success": False, "loss": 100}
                            else:
                                results[target] = {"success": True, "loss": "partial"}

                        except Exception as e:
                            results[target] = {"success": False, "error": str(e)}

                    # Evaluate results
                    failed_targets = [t for t, r in results.items() if not r.get("success")]

                    if failed_targets:
                        self.failed(f"Connectivity failed to: {failed_targets}")
                    else:
                        self.passed(f"All {len(TEST_DATA['targets'])} targets reachable")
        ''')

        script = self.AETEST_TEMPLATE.format(
            description=f"Ping connectivity test to {len(targets)} targets",
            agent_id=self.agent_id,
            generated_at=datetime.now().isoformat(),
            trigger=trigger.value,
            category=TestCategory.CONNECTIVITY.value,
            test_data=json.dumps(test_data, indent=4),
            test_classes=test_class,
        )

        return GeneratedTest(
            test_id=test_id,
            test_name=f"Ping Connectivity Test",
            category=TestCategory.CONNECTIVITY,
            trigger=trigger,
            description=f"Verify {source_device} can reach: {', '.join(targets)}",
            script=script,
            test_data=test_data,
            expected_outcomes=[f"All {len(targets)} targets should be reachable"],
            agent_id=self.agent_id,
        )

    def generate_neighbor_reachability_test(
        self,
        trigger: TestTrigger = TestTrigger.SELF_ASSESSMENT,
    ) -> GeneratedTest:
        """
        Generate test to verify all configured neighbors are reachable

        Automatically extracts neighbors from:
        - Interface peer configurations
        - OSPF neighbor configs
        - BGP peer configs
        """
        neighbors = set()

        # Extract from interfaces
        for intf in self.interfaces:
            l1 = intf.get("l1", {})
            if l1.get("peer_agent"):
                # Try to get peer IP from subnet
                subnet = l1.get("subnet", "")
                if subnet:
                    neighbors.add(subnet.split("/")[0])

        # Extract from OSPF
        for proto in self.protocols:
            if proto.get("p") in ["ospf", "ospfv3"]:
                for nbr in proto.get("neighbors", []):
                    if isinstance(nbr, dict):
                        neighbors.add(nbr.get("ip", nbr.get("router_id", "")))
                    else:
                        neighbors.add(str(nbr))

        # Extract from BGP
        for proto in self.protocols:
            if proto.get("p") in ["ibgp", "ebgp"]:
                for peer in proto.get("peers", []):
                    if isinstance(peer, dict):
                        neighbors.add(peer.get("ip", ""))
                    else:
                        neighbors.add(str(peer))

        # Filter empty strings
        neighbors = [n for n in neighbors if n]

        if not neighbors:
            # If no neighbors found, at least test loopback
            neighbors = [self.router_id]

        return self.generate_ping_test(
            targets=neighbors,
            source_device=self.agent_id,
            trigger=trigger,
        )

    # =========================================================================
    # Protocol State Tests
    # =========================================================================

    def generate_ospf_neighbor_test(
        self,
        expected_neighbors: Optional[List[Dict[str, Any]]] = None,
        trigger: TestTrigger = TestTrigger.SELF_ASSESSMENT,
    ) -> GeneratedTest:
        """
        Generate test to verify OSPF neighbor states

        Args:
            expected_neighbors: List of expected neighbors with state
            trigger: What triggered this test
        """
        test_id = self._next_test_id()

        # Extract OSPF config
        ospf_config = None
        for proto in self.protocols:
            if proto.get("p") in ["ospf", "ospfv3"]:
                ospf_config = proto
                break

        if not ospf_config:
            # No OSPF configured, generate minimal test
            test_data = {"devices": [self.agent_id], "expected_neighbors": []}
        else:
            # Build expected neighbors from config
            if expected_neighbors is None:
                expected_neighbors = []
                for nbr in ospf_config.get("neighbors", []):
                    if isinstance(nbr, dict):
                        expected_neighbors.append({
                            "router_id": nbr.get("router_id", nbr.get("ip", "")),
                            "expected_state": "FULL",
                        })

            test_data = {
                "devices": [self.agent_id],
                "expected_neighbors": expected_neighbors,
                "area": ospf_config.get("a", "0.0.0.0"),
            }

        test_class = textwrap.dedent('''
            class OSPFNeighborStateTest(aetest.Testcase):
                """Verify OSPF neighbor adjacencies"""

                @aetest.test
                def check_ospf_neighbors(self):
                    """Check all expected OSPF neighbors are in correct state"""
                    device = self.parent.parameters.get(TEST_DATA["devices"][0])

                    try:
                        # Get OSPF neighbor info (parsed if possible)
                        output = device.parse("show ip ospf neighbor")
                    except Exception:
                        # Fallback to raw
                        output = device.execute("show ip ospf neighbor")

                    expected = TEST_DATA.get("expected_neighbors", [])

                    if not expected:
                        self.skipped("No OSPF neighbors configured")
                        return

                    # Check each expected neighbor
                    missing = []
                    wrong_state = []

                    for nbr in expected:
                        router_id = nbr.get("router_id", "")
                        expected_state = nbr.get("expected_state", "FULL")

                        # Simple check - look for router ID in output
                        if isinstance(output, dict):
                            # Parsed output
                            found = False
                            for intf_data in output.get("interfaces", {}).values():
                                for neighbor_id, neighbor_data in intf_data.get("neighbors", {}).items():
                                    if neighbor_id == router_id:
                                        found = True
                                        state = neighbor_data.get("state", "").upper()
                                        if expected_state.upper() not in state:
                                            wrong_state.append(f"{router_id}: {state}")
                            if not found:
                                missing.append(router_id)
                        else:
                            # Raw output
                            if router_id not in str(output):
                                missing.append(router_id)

                    if missing:
                        self.failed(f"Missing OSPF neighbors: {missing}")
                    elif wrong_state:
                        self.failed(f"Neighbors in wrong state: {wrong_state}")
                    else:
                        self.passed(f"All {len(expected)} OSPF neighbors verified")
        ''')

        script = self.AETEST_TEMPLATE.format(
            description=f"OSPF neighbor state verification",
            agent_id=self.agent_id,
            generated_at=datetime.now().isoformat(),
            trigger=trigger.value,
            category=TestCategory.PROTOCOL_STATE.value,
            test_data=json.dumps(test_data, indent=4),
            test_classes=test_class,
        )

        return GeneratedTest(
            test_id=test_id,
            test_name="OSPF Neighbor State Test",
            category=TestCategory.PROTOCOL_STATE,
            trigger=trigger,
            description=f"Verify OSPF neighbors are FULL on {self.agent_id}",
            script=script,
            test_data=test_data,
            expected_outcomes=["All OSPF neighbors should be in FULL state"],
            agent_id=self.agent_id,
        )

    def generate_bgp_peer_test(
        self,
        expected_peers: Optional[List[Dict[str, Any]]] = None,
        trigger: TestTrigger = TestTrigger.SELF_ASSESSMENT,
    ) -> GeneratedTest:
        """
        Generate test to verify BGP peer states
        """
        test_id = self._next_test_id()

        # Extract BGP config
        bgp_config = None
        for proto in self.protocols:
            if proto.get("p") in ["ibgp", "ebgp"]:
                bgp_config = proto
                break

        if expected_peers is None and bgp_config:
            expected_peers = []
            for peer in bgp_config.get("peers", []):
                if isinstance(peer, dict):
                    expected_peers.append({
                        "peer_ip": peer.get("ip", ""),
                        "remote_as": peer.get("asn", ""),
                        "expected_state": "Established",
                    })

        test_data = {
            "devices": [self.agent_id],
            "expected_peers": expected_peers or [],
            "local_as": bgp_config.get("asn") if bgp_config else None,
        }

        test_class = textwrap.dedent('''
            class BGPPeerStateTest(aetest.Testcase):
                """Verify BGP peer sessions"""

                @aetest.test
                def check_bgp_peers(self):
                    """Check all expected BGP peers are established"""
                    device = self.parent.parameters.get(TEST_DATA["devices"][0])

                    try:
                        output = device.parse("show ip bgp summary")
                    except Exception:
                        output = device.execute("show ip bgp summary")

                    expected = TEST_DATA.get("expected_peers", [])

                    if not expected:
                        self.skipped("No BGP peers configured")
                        return

                    not_established = []

                    for peer in expected:
                        peer_ip = peer.get("peer_ip", "")
                        expected_state = peer.get("expected_state", "Established")

                        if isinstance(output, dict):
                            # Parsed output
                            neighbors = output.get("vrf", {}).get("default", {}).get("neighbor", {})
                            peer_data = neighbors.get(peer_ip, {})
                            state = peer_data.get("session_state", "")

                            if expected_state.lower() not in state.lower():
                                not_established.append(f"{peer_ip}: {state or 'not found'}")
                        else:
                            # Raw - simple check
                            if peer_ip not in str(output) or "Established" not in str(output):
                                not_established.append(peer_ip)

                    if not_established:
                        self.failed(f"BGP peers not established: {not_established}")
                    else:
                        self.passed(f"All {len(expected)} BGP peers established")
        ''')

        script = self.AETEST_TEMPLATE.format(
            description=f"BGP peer state verification",
            agent_id=self.agent_id,
            generated_at=datetime.now().isoformat(),
            trigger=trigger.value,
            category=TestCategory.PROTOCOL_STATE.value,
            test_data=json.dumps(test_data, indent=4),
            test_classes=test_class,
        )

        return GeneratedTest(
            test_id=test_id,
            test_name="BGP Peer State Test",
            category=TestCategory.PROTOCOL_STATE,
            trigger=trigger,
            description=f"Verify BGP peers are Established on {self.agent_id}",
            script=script,
            test_data=test_data,
            expected_outcomes=["All BGP peers should be in Established state"],
            agent_id=self.agent_id,
        )

    # =========================================================================
    # Interface Tests
    # =========================================================================

    def generate_interface_state_test(
        self,
        interfaces: Optional[List[str]] = None,
        trigger: TestTrigger = TestTrigger.SELF_ASSESSMENT,
    ) -> GeneratedTest:
        """
        Generate test to verify interface operational states
        """
        test_id = self._next_test_id()

        # Default to all configured interfaces
        if interfaces is None:
            interfaces = []
            for intf in self.interfaces:
                intf_name = intf.get("n", intf.get("id", ""))
                expected_state = intf.get("s", "up")
                if intf_name:
                    interfaces.append({
                        "name": intf_name,
                        "expected_state": expected_state,
                    })

        test_data = {
            "devices": [self.agent_id],
            "interfaces": interfaces,
        }

        test_class = textwrap.dedent('''
            class InterfaceStateTest(aetest.Testcase):
                """Verify interface operational states"""

                @aetest.test
                def check_interface_states(self):
                    """Check all interfaces are in expected state"""
                    device = self.parent.parameters.get(TEST_DATA["devices"][0])

                    try:
                        output = device.parse("show interfaces")
                    except Exception:
                        output = device.execute("show interfaces")

                    interfaces = TEST_DATA.get("interfaces", [])

                    if not interfaces:
                        self.skipped("No interfaces to check")
                        return

                    state_mismatches = []

                    for intf in interfaces:
                        name = intf.get("name", "")
                        expected = intf.get("expected_state", "up").lower()

                        if isinstance(output, dict):
                            intf_data = output.get(name, {})
                            oper_status = intf_data.get("oper_status", "").lower()

                            if expected not in oper_status and oper_status not in expected:
                                state_mismatches.append(f"{name}: expected {expected}, got {oper_status}")
                        else:
                            # Raw output check
                            if f"{name} is down" in str(output).lower() and expected == "up":
                                state_mismatches.append(f"{name}: expected up, is down")

                    if state_mismatches:
                        self.failed(f"Interface state mismatches: {state_mismatches}")
                    else:
                        self.passed(f"All {len(interfaces)} interfaces in expected state")
        ''')

        script = self.AETEST_TEMPLATE.format(
            description=f"Interface state verification",
            agent_id=self.agent_id,
            generated_at=datetime.now().isoformat(),
            trigger=trigger.value,
            category=TestCategory.INTERFACE.value,
            test_data=json.dumps(test_data, indent=4),
            test_classes=test_class,
        )

        return GeneratedTest(
            test_id=test_id,
            test_name="Interface State Test",
            category=TestCategory.INTERFACE,
            trigger=trigger,
            description=f"Verify interface states on {self.agent_id}",
            script=script,
            test_data=test_data,
            expected_outcomes=["All interfaces should be in expected operational state"],
            agent_id=self.agent_id,
        )

    # =========================================================================
    # Routing Tests
    # =========================================================================

    def generate_route_presence_test(
        self,
        routes: List[Dict[str, Any]],
        trigger: TestTrigger = TestTrigger.SELF_ASSESSMENT,
    ) -> GeneratedTest:
        """
        Generate test to verify specific routes are present in RIB

        Args:
            routes: List of routes to verify, each with:
                - prefix: The network prefix (e.g., "10.0.0.0/24")
                - protocol: Expected source protocol (optional)
                - next_hop: Expected next-hop (optional)
        """
        test_id = self._next_test_id()

        test_data = {
            "devices": [self.agent_id],
            "routes": routes,
        }

        test_class = textwrap.dedent('''
            class RoutePresenceTest(aetest.Testcase):
                """Verify expected routes are in routing table"""

                @aetest.test
                def check_routes(self):
                    """Check all expected routes are present"""
                    device = self.parent.parameters.get(TEST_DATA["devices"][0])

                    try:
                        output = device.parse("show ip route")
                    except Exception:
                        output = device.execute("show ip route")

                    routes = TEST_DATA.get("routes", [])

                    if not routes:
                        self.skipped("No routes to verify")
                        return

                    missing_routes = []

                    for route in routes:
                        prefix = route.get("prefix", "")

                        if isinstance(output, dict):
                            # Check parsed routing table
                            vrf_routes = output.get("vrf", {}).get("default", {}).get("address_family", {})
                            found = False
                            for af_data in vrf_routes.values():
                                if prefix in af_data.get("routes", {}):
                                    found = True
                                    break
                            if not found:
                                missing_routes.append(prefix)
                        else:
                            # Check raw output
                            if prefix.split("/")[0] not in str(output):
                                missing_routes.append(prefix)

                    if missing_routes:
                        self.failed(f"Missing routes: {missing_routes}")
                    else:
                        self.passed(f"All {len(routes)} expected routes present")
        ''')

        script = self.AETEST_TEMPLATE.format(
            description=f"Route presence verification",
            agent_id=self.agent_id,
            generated_at=datetime.now().isoformat(),
            trigger=trigger.value,
            category=TestCategory.ROUTING.value,
            test_data=json.dumps(test_data, indent=4),
            test_classes=test_class,
        )

        return GeneratedTest(
            test_id=test_id,
            test_name="Route Presence Test",
            category=TestCategory.ROUTING,
            trigger=trigger,
            description=f"Verify {len(routes)} routes present on {self.agent_id}",
            script=script,
            test_data=test_data,
            expected_outcomes=[f"All {len(routes)} routes should be in RIB"],
            agent_id=self.agent_id,
        )

    # =========================================================================
    # Comprehensive Self-Test
    # =========================================================================

    def generate_comprehensive_self_test(
        self,
        trigger: TestTrigger = TestTrigger.SELF_ASSESSMENT,
    ) -> GeneratedTest:
        """
        Generate a comprehensive test covering all aspects of the agent's config

        This is the "full self-assessment" an agent runs to validate its health.
        """
        test_id = self._next_test_id()

        # Build comprehensive test data from agent config
        neighbors = []
        for intf in self.interfaces:
            l1 = intf.get("l1", {})
            if l1.get("peer_agent"):
                subnet = l1.get("subnet", "")
                if subnet:
                    neighbors.append(subnet.split("/")[0])

        ospf_neighbors = []
        bgp_peers = []

        for proto in self.protocols:
            if proto.get("p") in ["ospf", "ospfv3"]:
                for nbr in proto.get("neighbors", []):
                    if isinstance(nbr, dict):
                        ospf_neighbors.append(nbr.get("router_id", ""))
            if proto.get("p") in ["ibgp", "ebgp"]:
                for peer in proto.get("peers", []):
                    if isinstance(peer, dict):
                        bgp_peers.append(peer.get("ip", ""))

        interfaces = []
        for intf in self.interfaces:
            intf_name = intf.get("n", intf.get("id", ""))
            if intf_name:
                interfaces.append({
                    "name": intf_name,
                    "expected_state": intf.get("s", "up"),
                })

        test_data = {
            "devices": [self.agent_id],
            "agent_id": self.agent_id,
            "router_id": self.router_id,
            "ping_targets": neighbors,
            "ospf_neighbors": ospf_neighbors,
            "bgp_peers": bgp_peers,
            "interfaces": interfaces,
        }

        test_classes = textwrap.dedent('''
            class SelfAssessmentConnectivity(aetest.Testcase):
                """Connectivity self-assessment"""

                @aetest.test
                def ping_neighbors(self):
                    """Verify connectivity to all neighbors"""
                    device = self.parent.parameters.get(TEST_DATA["devices"][0])
                    targets = TEST_DATA.get("ping_targets", [])

                    if not targets:
                        self.skipped("No neighbors to ping")
                        return

                    failed = []
                    for target in targets:
                        try:
                            output = device.execute(f"ping {target} count 3 timeout 2")
                            if "100% packet loss" in output.lower() or "0 packets received" in output.lower():
                                failed.append(target)
                        except Exception as e:
                            failed.append(f"{target} (error: {e})")

                    if failed:
                        self.failed(f"Unreachable neighbors: {failed}")
                    else:
                        self.passed(f"All {len(targets)} neighbors reachable")


            class SelfAssessmentOSPF(aetest.Testcase):
                """OSPF self-assessment"""

                @aetest.test
                def check_ospf_adjacencies(self):
                    """Verify OSPF adjacencies"""
                    device = self.parent.parameters.get(TEST_DATA["devices"][0])
                    expected = TEST_DATA.get("ospf_neighbors", [])

                    if not expected:
                        self.skipped("No OSPF neighbors configured")
                        return

                    try:
                        output = device.execute("show ip ospf neighbor")
                    except Exception as e:
                        self.errored(f"Failed to get OSPF neighbors: {e}")
                        return

                    missing = [n for n in expected if n and n not in str(output)]

                    if missing:
                        self.failed(f"Missing OSPF neighbors: {missing}")
                    else:
                        self.passed(f"All {len(expected)} OSPF neighbors present")


            class SelfAssessmentBGP(aetest.Testcase):
                """BGP self-assessment"""

                @aetest.test
                def check_bgp_sessions(self):
                    """Verify BGP sessions"""
                    device = self.parent.parameters.get(TEST_DATA["devices"][0])
                    expected = TEST_DATA.get("bgp_peers", [])

                    if not expected:
                        self.skipped("No BGP peers configured")
                        return

                    try:
                        output = device.execute("show ip bgp summary")
                    except Exception as e:
                        self.errored(f"Failed to get BGP summary: {e}")
                        return

                    # Simple check - just verify peer IPs appear
                    missing = [p for p in expected if p and p not in str(output)]

                    if missing:
                        self.failed(f"Missing BGP peers: {missing}")
                    else:
                        self.passed(f"All {len(expected)} BGP peers present")


            class SelfAssessmentInterfaces(aetest.Testcase):
                """Interface self-assessment"""

                @aetest.test
                def check_interface_states(self):
                    """Verify interface operational states"""
                    device = self.parent.parameters.get(TEST_DATA["devices"][0])
                    interfaces = TEST_DATA.get("interfaces", [])

                    if not interfaces:
                        self.skipped("No interfaces to check")
                        return

                    try:
                        output = device.execute("show interfaces")
                    except Exception as e:
                        self.errored(f"Failed to get interfaces: {e}")
                        return

                    issues = []
                    for intf in interfaces:
                        name = intf.get("name", "")
                        expected = intf.get("expected_state", "up")

                        if expected == "up" and f"{name} is down" in output.lower():
                            issues.append(f"{name} is down")

                    if issues:
                        self.failed(f"Interface issues: {issues}")
                    else:
                        self.passed(f"All {len(interfaces)} interfaces operational")
        ''')

        script = self.AETEST_TEMPLATE.format(
            description=f"Comprehensive self-assessment for {self.agent_id}",
            agent_id=self.agent_id,
            generated_at=datetime.now().isoformat(),
            trigger=trigger.value,
            category="comprehensive",
            test_data=json.dumps(test_data, indent=4),
            test_classes=test_classes,
        )

        return GeneratedTest(
            test_id=test_id,
            test_name="Comprehensive Self-Assessment",
            category=TestCategory.PROTOCOL_STATE,
            trigger=trigger,
            description=f"Full self-assessment of {self.agent_id}",
            script=script,
            test_data=test_data,
            expected_outcomes=[
                "All neighbors should be reachable",
                "All OSPF adjacencies should be FULL",
                "All BGP peers should be Established",
                "All interfaces should be operational",
            ],
            agent_id=self.agent_id,
        )


class SelfTestingAgent:
    """
    Agent capability for autonomous self-testing

    Combines the DynamicTestGenerator with pyATS MCP execution
    to create a fully autonomous testing agent.
    """

    def __init__(
        self,
        agent_config: Dict[str, Any],
        pyats_client: Any,  # PyATSMCPClient
    ):
        """
        Initialize self-testing agent

        Args:
            agent_config: Agent's TOON configuration
            pyats_client: Connected PyATSMCPClient instance
        """
        self.agent_config = agent_config
        self.agent_id = agent_config.get("id", "unknown")
        self.pyats_client = pyats_client
        self.generator = DynamicTestGenerator(agent_config)
        self._test_history: List[TestExecutionResult] = []
        self._callbacks: List[Callable[[TestExecutionResult], None]] = []

    def register_callback(
        self,
        callback: Callable[[TestExecutionResult], None]
    ) -> None:
        """Register callback for test results"""
        self._callbacks.append(callback)

    async def execute_test(
        self,
        test: GeneratedTest
    ) -> TestExecutionResult:
        """
        Execute a generated test via pyATS MCP

        Args:
            test: GeneratedTest to execute

        Returns:
            TestExecutionResult with pass/fail details
        """
        logger.info(f"Executing dynamic test: {test.test_name} ({test.test_id})")

        start_time = datetime.now()

        try:
            # Execute via pyATS MCP
            result = await self.pyats_client.run_test(test.script)

            duration = int((datetime.now() - start_time).total_seconds() * 1000)

            exec_result = TestExecutionResult(
                test_id=test.test_id,
                success=result.success,
                passed=result.passed,
                failed=result.failed,
                errored=result.errored,
                sections=result.sections,
                raw_output=result.output,
                duration_ms=duration,
            )

            # Generate recommendations based on failures
            if not result.success:
                exec_result.recommendations = self._generate_recommendations(
                    test, result
                )

            # Store in history
            self._test_history.append(exec_result)

            # Notify callbacks
            for callback in self._callbacks:
                try:
                    callback(exec_result)
                except Exception as e:
                    logger.error(f"Callback error: {e}")

            return exec_result

        except Exception as e:
            logger.error(f"Test execution failed: {e}")
            return TestExecutionResult(
                test_id=test.test_id,
                success=False,
                passed=0,
                failed=0,
                errored=1,
                sections=[],
                recommendations=[f"Test execution error: {str(e)}"],
            )

    def _generate_recommendations(
        self,
        test: GeneratedTest,
        result: Any
    ) -> List[str]:
        """Generate recommendations based on test failures"""
        recommendations = []

        if test.category == TestCategory.CONNECTIVITY:
            recommendations.append("Check physical layer connectivity")
            recommendations.append("Verify IP addressing and subnet masks")
            recommendations.append("Check for ACLs blocking traffic")

        elif test.category == TestCategory.PROTOCOL_STATE:
            if "OSPF" in test.test_name:
                recommendations.append("Verify OSPF area configuration matches")
                recommendations.append("Check hello/dead timer compatibility")
                recommendations.append("Verify MTU matches on both ends")
            elif "BGP" in test.test_name:
                recommendations.append("Verify BGP neighbor IP and AS number")
                recommendations.append("Check for eBGP multihop if needed")
                recommendations.append("Verify route policies allow prefixes")

        elif test.category == TestCategory.INTERFACE:
            recommendations.append("Check physical cable connections")
            recommendations.append("Verify interface is not administratively down")
            recommendations.append("Check for speed/duplex mismatches")

        elif test.category == TestCategory.ROUTING:
            recommendations.append("Verify route is being advertised")
            recommendations.append("Check for route filtering or policies")
            recommendations.append("Verify next-hop is reachable")

        return recommendations

    async def run_self_assessment(
        self,
        trigger: TestTrigger = TestTrigger.SELF_ASSESSMENT,
    ) -> TestExecutionResult:
        """
        Run comprehensive self-assessment

        This is the primary entry point for agent self-testing.
        """
        logger.info(f"Agent {self.agent_id} running self-assessment")

        test = self.generator.generate_comprehensive_self_test(trigger=trigger)
        return await self.execute_test(test)

    async def test_connectivity_to(
        self,
        targets: List[str],
        trigger: TestTrigger = TestTrigger.SELF_ASSESSMENT,
    ) -> TestExecutionResult:
        """Test connectivity to specific targets"""
        test = self.generator.generate_ping_test(
            targets=targets,
            source_device=self.agent_id,
            trigger=trigger,
        )
        return await self.execute_test(test)

    async def test_ospf_neighbors(
        self,
        trigger: TestTrigger = TestTrigger.STATE_CHANGE,
    ) -> TestExecutionResult:
        """Test OSPF neighbor states"""
        test = self.generator.generate_ospf_neighbor_test(trigger=trigger)
        return await self.execute_test(test)

    async def test_bgp_peers(
        self,
        trigger: TestTrigger = TestTrigger.STATE_CHANGE,
    ) -> TestExecutionResult:
        """Test BGP peer states"""
        test = self.generator.generate_bgp_peer_test(trigger=trigger)
        return await self.execute_test(test)

    async def test_interfaces(
        self,
        trigger: TestTrigger = TestTrigger.STATE_CHANGE,
    ) -> TestExecutionResult:
        """Test interface states"""
        test = self.generator.generate_interface_state_test(trigger=trigger)
        return await self.execute_test(test)

    async def test_route_presence(
        self,
        routes: List[Dict[str, Any]],
        trigger: TestTrigger = TestTrigger.STATE_CHANGE,
    ) -> TestExecutionResult:
        """Test that specific routes are present"""
        test = self.generator.generate_route_presence_test(
            routes=routes,
            trigger=trigger,
        )
        return await self.execute_test(test)

    def get_test_history(
        self,
        limit: int = 100
    ) -> List[TestExecutionResult]:
        """Get recent test execution history"""
        return self._test_history[-limit:]

    def get_pass_rate(self) -> float:
        """Calculate overall test pass rate"""
        if not self._test_history:
            return 0.0

        total_passed = sum(r.passed for r in self._test_history)
        total_tests = sum(r.passed + r.failed + r.errored for r in self._test_history)

        if total_tests == 0:
            return 0.0

        return (total_passed / total_tests) * 100
